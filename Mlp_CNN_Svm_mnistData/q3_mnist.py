# -*- coding: utf-8 -*-
"""Q3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F8Hy3ZDcrbgwBZaK58mrvVaJCKxPefrx
"""

import sys 
import pandas as pd
from sklearn.metrics import classification_report
from sklearn.model_selection import train_test_split
import numpy as np
import cv2
import matplotlib.pyplot as plt 
from sklearn.metrics import mean_squared_error
import matplotlib.image as mpimg
from sklearn.metrics import confusion_matrix,accuracy_score,f1_score
from sklearn.metrics import precision_score, recall_score, r2_score
from os import listdir
from os.path import isfile, join
from sklearn import datasets, svm, metrics
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import cross_val_score
from tensorflow.python.keras.layers import Dense
from tensorflow.python.keras import Sequential
from keras.utils import to_categorical
import warnings
from keras.layers import Input
import sklearn.model_selection as model_selection
from numpy import array
from tensorflow.python.keras.layers import  Dense, Conv2D, Flatten
from tensorflow.python.keras.layers.pooling import MaxPooling2D

#!pip install python-mnist

#!pip install idx2numpy

import idx2numpy
path = sys.argv[1]
#path = '/content/drive/My Drive/Q3'
a = 't10k-images-idx3-ubyte'
b = 't10k-labels-idx1-ubyte'
c = 'train-images-idx3-ubyte'
d = 'train-labels-idx1-ubyte'
path1 = path+'/'+c
path2 = path+'/'+d
path3 = path+'/'+a
X3_train = idx2numpy.convert_from_file(path1)
Y3_train = idx2numpy.convert_from_file(path2)
X3_test  = idx2numpy.convert_from_file(path3)

# X3_train
# ,Y3_train = mndata.load_training()
# X3_test  = mndata.load_testing()
# files = [f for f in listdir(path) if isfile(join(path,f))]
# print(len(files))

# from mnist import MNIST
# mndata = MNIST('/content/drive/My Drive/Q3/')
# X3_train,Y3_train = mndata.load_training()
#  X3_test,Y3_test  = mndata.load_testing()
#  print(len(X3_test))

X3_train = np.array(X3_train).astype(np.float32)
#print(X3_train.shape)
Y3_train = np.array(Y3_train)
X3_test = np.array(X3_test).astype(np.float32)
#Y3_test = np.array(Y3_test)
# print(X3_test.shape)

X32_train = X3_train.reshape(X3_train.shape[0],X3_train.shape[1],X3_train.shape[2],1)
X32_test = X3_test.reshape(X3_test.shape[0],X3_test.shape[1],X3_test.shape[2],1)
Y32_train = to_categorical(Y3_train,10)
# Y32_test = to_categorical(Y3_test,10)
warnings.simplefilter("ignore")
#print(X32_train.shape)

def predict(X32_test,model_CNN):
  classes   = model_CNN.predict_classes(X32_test)
  return classes


def ApplyCnn(X32_train,X32_test,Y32_train):

  model_CNN = Sequential()
  model_CNN.add(Conv2D(64, kernel_size=3, activation='relu', input_shape=(X3_train.shape[1],X3_train.shape[2],1)))
  model_CNN.add(MaxPooling2D(pool_size=(2, 2)))
  model_CNN.add(Conv2D(32, kernel_size=3, activation='relu'))
  model_CNN.add(MaxPooling2D(pool_size=(2, 2)))
  model_CNN.add(Conv2D(16, kernel_size=3, activation='relu'))
  model_CNN.add(MaxPooling2D(pool_size=(2, 2)))
  model_CNN.add(Flatten())
  model_CNN.add(Dense(10, activation='softmax'))
  model_CNN.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
  model_CNN.fit(X32_train, Y32_train, epochs=10,verbose=0)
  return predict(X32_test,model_CNN)

# _, accuracy = model_CNN.evaluate(X32_test,Y32_test)
# print('Accuracy: %.2f' % (accuracy*100))

classes   = ApplyCnn(X32_train,X32_test,Y32_train)
# print(classes)
for i in classes:
  print(i)

