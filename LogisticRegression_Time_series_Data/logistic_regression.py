# -*- coding: utf-8 -*-
"""Q2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jt7o25-Bh5feEllXU88g7YK7LO7unUbf
"""

import pandas as pd
import sys
from sklearn.metrics import classification_report
from sklearn.model_selection import train_test_split
import numpy as np
import cv2
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error
import matplotlib.image as mpimg
from sklearn.metrics import confusion_matrix, accuracy_score, f1_score
from sklearn.metrics import precision_score, recall_score, r2_score
from os import listdir
from os.path import isfile, join
from sklearn import datasets, svm, metrics

LabelDict = {}


def Read(Path):
    X_train = []
    Y_train = []
    with open(train_file) as fp:
        Lines = fp.readlines()
        k = 0
        for line in Lines:
            split_val = line.split(" ")
            label = (split_val[1].strip())
            A = split_val[0]
            # strn = A.split(".")
            # path = "/content/drive/My Drive/A3"+strn[1]+"."+strn[2]
            path = A
            # print(split_val[0])
            img = cv2.imread(path)
            if img is None:
                continue
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            scale_percent = 0.6
            width = int(64)
            height = int(64)
            dimension = (width, height)
            resized = cv2.resize(gray, dimension, cv2.INTER_AREA)
            # print(resized.shape)
            # print(gray.shape)
            resized = resized.flatten()
            # print(resized.shape)
            X_train.append(resized)
            if label in LabelDict.keys():
                Y_train.append(LabelDict[label])
            else:
                LabelDict[label] = k
                Y_train.append(k)
                k = k+1
    X_train = np.array(X_train)
    Y_train = np.array(Y_train)
    return X_train, Y_train


def ReadTest(filepath):
    X_test = []
    with open(test_file) as fp:
        Lines = fp.readlines()
        for line in Lines:
            A = line.rstrip('\n')
            A = line.strip()
            # strn = A.split(".")
            # A   = "/content/drive/My Drive/A3"+strn[1]+"."+strn[2]
            # print(A)
            # #print("hey")
            A = line.strip()
            img = cv2.imread(A)
            if img is None:
                continue
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            scale_percent = 0.6
            # width = int(gray.shape[1]*scale_percent)
            # height= int(gray.shape[0]*scale_percent)
            # dimension = (width,height)
            dimension = (64, 64)
            resized = cv2.resize(gray, dimension, cv2.INTER_AREA)
            # print(resized.shape)
            # print(gray.shape)
            resized = resized.flatten()
            # print(resized.shape)
            X_test.append(resized)
    X_test = np.array(X_test)
    return X_test

# test_file="sample_test.txt"
# A= ReadTest(test_file)


def sigmoid(x):
    return np.exp(x) / (1 + np.exp(x))


class PCA:
    def find_eigen_vector(self, Xdata):
        Xdata = self.standarization(Xdata)
        U, S, V = np.linalg.svd(Xdata.T)
        return U

    def standarization(self, X):
        X = (X - X.mean())/X.std()
        return X

    def compute_pcaData(self, components, W_mat, Xdata):
        Xdata = self.standarization(Xdata)
        W_mat = W_mat[0:components, ]
        # print(Xdata.shape)
        # print(W_mat.shape)
        pcaData = Xdata.dot(W_mat.T)
        return pcaData

    def Inverse_Transform(self, W_mat, PcaData, components):
        W_mat = W_mat[0:components, ]
        data_original = np.dot(PcaData, W_mat)
        return data_original


# train_file="/content/drive/My Drive/A3/sample_train.txt"
# test_file="/content/drive/My Drive/A3/sample_test.txt"
train_file = sys.argv[1]
test_file = sys.argv[2]
X1_train, Y1_train = Read(train_file)
X1_test = ReadTest(test_file)
# print(X1_train)
# print(X1_test)
Ldict = {}
Ldict = {value: key for key, value in LabelDict.items()}
# print(Ldict)

pca = PCA()
eig_vec = pca.find_eigen_vector(X1_train)

# print(X1_test.shape)
# print(X1_train.shape)

pca_data = pca.compute_pcaData(300, eig_vec, X1_train)
X1_test = pca.compute_pcaData(300, eig_vec, X1_test)


class Logistic_Regression:
    alpha = 0.01
    iteration = 1000

    def train(self, Xdata, Ydata):
        ones = np.ones([Xdata.shape[0], 1])
        Xdata = np.concatenate((Xdata, ones), axis=1)
        Ydata = np.array(Ydata)
        Ydata = Ydata.reshape(len(Ydata), 1)
        self.gradient_Descent(Xdata, Ydata)

    def gradient_Descent(self, train_X, train_Y):
        self.theta = np.zeros([1, train_X.shape[1]])
        for i in range(self.iteration):
            loss = sigmoid(np.dot(train_X, self.theta.T)) - train_Y
            DotProduct = np.dot(train_X.T, loss)
            grad = DotProduct/len(train_Y)
            diff_theta = self.alpha * grad.T
            self.theta = self.theta - diff_theta

    def predict_probability(self, test_X):
        ones = np.ones((1, len(test_X)))
        test_X = np.concatenate((test_X, ones.T), axis=1)
        temp_X = test_X @ self.theta.T
        y_pred = sigmoid(temp_X)
        y_pred = y_pred.flatten()
        return y_pred


class MultiClass:
    models = {}

    def fit(self, X, y):
        self.labels = np.unique(y)
        for i in range(0, len(self.labels)):
            Y_label = [1 if c == self.labels[i] else 0 for c in y]
            LR = Logistic_Regression()
            LR.train(X, Y_label)
            self.models[self.labels[i]] = LR

    def predict(self, test_X):
        results = np.zeros([len(test_X), 1 + self.labels.shape[0]])
        for key in self.models:
            model = self.models[key]
            y = model.predict_probability(test_X)
            for i in range(len(y)):
                results[i][key] += y[i]
        return np.argmax(results, axis=1)


X_Train, Y_Train = pca_data, Y1_train

reg = MultiClass()
reg.fit(X_Train, Y_Train)
# print(reg.labels)
y_pred = reg.predict(X1_test)

for i in range(y_pred.shape[0]):
    print(Ldict[y_pred[i]])
